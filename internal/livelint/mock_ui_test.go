// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package livelint_test

import (
	"github.com/bespinian/livelint/internal/livelint"
	tea "github.com/charmbracelet/bubbletea"
	"sync"
)

// Ensure, that UserInteractionMock does implement livelint.UserInteraction.
// If this is not the case, regenerate this file with moq.
var _ livelint.UserInteraction = &UserInteractionMock{}

// UserInteractionMock is a mock implementation of livelint.UserInteraction.
//
//	func TestSomethingThatUsesUserInteraction(t *testing.T) {
//
//		// make and configure a mocked livelint.UserInteraction
//		mockedUserInteraction := &UserInteractionMock{
//			AskYesNoFunc: func(question string) bool {
//				panic("mock out the AskYesNo method")
//			},
//			SendFunc: func(msg tea.Msg)  {
//				panic("mock out the Send method")
//			},
//		}
//
//		// use mockedUserInteraction in code that requires livelint.UserInteraction
//		// and then make assertions.
//
//	}
type UserInteractionMock struct {
	// AskYesNoFunc mocks the AskYesNo method.
	AskYesNoFunc func(question string) bool

	// SendFunc mocks the Send method.
	SendFunc func(msg tea.Msg)

	// calls tracks calls to the methods.
	calls struct {
		// AskYesNo holds details about calls to the AskYesNo method.
		AskYesNo []struct {
			// Question is the question argument value.
			Question string
		}
		// Send holds details about calls to the Send method.
		Send []struct {
			// Msg is the msg argument value.
			Msg tea.Msg
		}
	}
	lockAskYesNo sync.RWMutex
	lockSend     sync.RWMutex
}

// AskYesNo calls AskYesNoFunc.
func (mock *UserInteractionMock) AskYesNo(question string) bool {
	if mock.AskYesNoFunc == nil {
		panic("UserInteractionMock.AskYesNoFunc: method is nil but UserInteraction.AskYesNo was just called")
	}
	callInfo := struct {
		Question string
	}{
		Question: question,
	}
	mock.lockAskYesNo.Lock()
	mock.calls.AskYesNo = append(mock.calls.AskYesNo, callInfo)
	mock.lockAskYesNo.Unlock()
	return mock.AskYesNoFunc(question)
}

// AskYesNoCalls gets all the calls that were made to AskYesNo.
// Check the length with:
//
//	len(mockedUserInteraction.AskYesNoCalls())
func (mock *UserInteractionMock) AskYesNoCalls() []struct {
	Question string
} {
	var calls []struct {
		Question string
	}
	mock.lockAskYesNo.RLock()
	calls = mock.calls.AskYesNo
	mock.lockAskYesNo.RUnlock()
	return calls
}

// Send calls SendFunc.
func (mock *UserInteractionMock) Send(msg tea.Msg) {
	if mock.SendFunc == nil {
		panic("UserInteractionMock.SendFunc: method is nil but UserInteraction.Send was just called")
	}
	callInfo := struct {
		Msg tea.Msg
	}{
		Msg: msg,
	}
	mock.lockSend.Lock()
	mock.calls.Send = append(mock.calls.Send, callInfo)
	mock.lockSend.Unlock()
	mock.SendFunc(msg)
}

// SendCalls gets all the calls that were made to Send.
// Check the length with:
//
//	len(mockedUserInteraction.SendCalls())
func (mock *UserInteractionMock) SendCalls() []struct {
	Msg tea.Msg
} {
	var calls []struct {
		Msg tea.Msg
	}
	mock.lockSend.RLock()
	calls = mock.calls.Send
	mock.lockSend.RUnlock()
	return calls
}
